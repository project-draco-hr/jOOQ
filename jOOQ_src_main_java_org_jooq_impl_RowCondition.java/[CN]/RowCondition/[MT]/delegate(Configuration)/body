{
  SQLDialect dialect=configuration.getDialect();
  if (asList(EQUALS,NOT_EQUALS).contains(comparator) && asList(ASE,DERBY,FIREBIRD,INGRES,SQLSERVER,SQLITE,SYBASE).contains(dialect)) {
    List<Condition> conditions=new ArrayList<Condition>();
    Field<?>[] leftFields=left.getFields();
    Field<?>[] rightFields=right.getFields();
    for (int i=0; i < leftFields.length; i++) {
      conditions.add(leftFields[i].equal((Field)rightFields[i]));
    }
    Condition result=new CombinedCondition(Operator.AND,conditions);
    if (comparator == NOT_EQUALS) {
      result=result.not();
    }
    return (QueryPartInternal)result;
  }
 else   if (asList(GREATER,GREATER_OR_EQUAL,LESS,LESS_OR_EQUAL).contains(comparator) && asList(DERBY,CUBRID,FIREBIRD,ORACLE,SQLSERVER,SQLITE,SYBASE).contains(dialect)) {
    Comparator order=(comparator == GREATER) ? GREATER : (comparator == GREATER_OR_EQUAL) ? GREATER : (comparator == LESS) ? LESS : (comparator == LESS_OR_EQUAL) ? LESS : null;
    boolean equal=(comparator == GREATER_OR_EQUAL) || (comparator == LESS_OR_EQUAL);
    List<Condition> outer=new ArrayList<Condition>();
    Field<?>[] leftFields=left.getFields();
    Field<?>[] rightFields=right.getFields();
    for (int i=0; i < leftFields.length; i++) {
      List<Condition> inner=new ArrayList<Condition>();
      for (int j=0; j < i; j++) {
        inner.add(leftFields[j].equal((Field)rightFields[j]));
      }
      inner.add(leftFields[i].compare(order,(Field)rightFields[i]));
      outer.add(new CombinedCondition(Operator.AND,inner));
    }
    if (equal) {
      outer.add(new RowCondition(left,right,Comparator.EQUALS));
    }
    Condition result=new CombinedCondition(Operator.OR,outer);
    return (QueryPartInternal)result;
  }
 else {
    return new Native();
  }
}

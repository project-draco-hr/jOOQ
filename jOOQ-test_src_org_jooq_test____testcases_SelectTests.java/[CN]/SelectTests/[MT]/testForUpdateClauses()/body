{
switch (getDialect()) {
case SQLITE:
    log.info("SKIPPING","FOR UPDATE tests");
  return;
}
final Factory create1=create();
final Factory create2=create();
create2.setConnection(getNewConnection());
create2.getConnection().setAutoCommit(false);
final Vector<String> execOrder=new Vector<String>();
try {
final Thread t1=new Thread(new Runnable(){
  @Override public void run(){
    sleep(2000);
    execOrder.add("t1-block");
    try {
      create1.select(TAuthor_ID()).from(TAuthor()).forUpdate().fetch();
    }
 catch (    DataAccessException ignore) {
    }
 finally {
      execOrder.add("t1-fail-or-t2-commit");
    }
  }
}
);
final Thread t2=new Thread(new Runnable(){
  @Override public void run(){
    execOrder.add("t2-exec");
    Result<A> result2=create2.selectFrom(TAuthor()).forUpdate().fetch();
    assertEquals(2,result2.size());
    execOrder.add("t2-signal");
    sleep(4000);
    execOrder.add("t1-fail-or-t2-commit");
    try {
      create2.getConnection().commit();
      create2.getConnection().close();
    }
 catch (    Exception e) {
    }
  }
}
);
t1.start();
t2.start();
t1.join();
t2.join();
assertEquals(asList("t2-exec","t2-signal","t1-block","t1-fail-or-t2-commit","t1-fail-or-t2-commit"),execOrder);
}
  finally {
try {
  create2.getConnection().close();
}
 catch (Exception e) {
}
}
switch (getDialect()) {
case INGRES:
case ORACLE:
log.info("SKIPPING","LIMIT .. OFFSET .. FOR UPDATE");
break;
default :
{
Result<Record> result3=create().select(TAuthor_ID()).from(TAuthor()).limit(5).offset(0).forUpdate().fetch();
assertEquals(2,result3.size());
Result<A> result4=create().selectFrom(TAuthor()).limit(5).offset(0).forUpdate().fetch();
assertEquals(2,result4.size());
}
}
switch (getDialect()) {
case ASE:
case DB2:
case DERBY:
case HSQLDB:
case H2:
case INGRES:
case MYSQL:
case POSTGRES:
case SYBASE:
log.info("SKIPPING","FOR UPDATE .. WAIT/NOWAIT tests");
break;
default :
{
Result<Record> result=create().select(TAuthor_ID()).from(TAuthor()).forUpdate().wait(2).fetch();
assertEquals(2,result.size());
result=create().select(TAuthor_ID()).from(TAuthor()).forUpdate().noWait().fetch();
assertEquals(2,result.size());
result=create().select(TAuthor_ID()).from(TAuthor()).forUpdate().skipLocked().fetch();
assertEquals(2,result.size());
Result<A> result2=create().selectFrom(TAuthor()).forUpdate().of(TAuthor_LAST_NAME(),TAuthor_FIRST_NAME()).wait(2).fetch();
assertEquals(2,result2.size());
result2=create().selectFrom(TAuthor()).forUpdate().of(TAuthor_LAST_NAME(),TAuthor_FIRST_NAME()).noWait().fetch();
assertEquals(2,result2.size());
result2=create().selectFrom(TAuthor()).forUpdate().of(TAuthor_LAST_NAME(),TAuthor_FIRST_NAME()).skipLocked().fetch();
assertEquals(2,result2.size());
}
}
switch (getDialect()) {
case MYSQL:
log.info("SKIPPING","FOR UPDATE OF tests");
break;
case DB2:
case DERBY:
case H2:
case HSQLDB:
case INGRES:
case ORACLE:
case SYBASE:
{
Result<Record> result=create().select(TAuthor_ID()).from(TAuthor()).forUpdate().of(TAuthor_ID(),TAuthor_LAST_NAME(),TAuthor_FIRST_NAME()).fetch();
assertEquals(2,result.size());
Result<A> result2=create().selectFrom(TAuthor()).forUpdate().of(TAuthor_ID(),TAuthor_LAST_NAME(),TAuthor_FIRST_NAME()).fetch();
assertEquals(2,result2.size());
}
case POSTGRES:
{
Result<Record> result=create().select(TAuthor_ID()).from(TAuthor()).forUpdate().of(TAuthor()).fetch();
assertEquals(2,result.size());
Result<A> result2=create().selectFrom(TAuthor()).forUpdate().of(TAuthor()).fetch();
assertEquals(2,result2.size());
break;
}
}
switch (getDialect()) {
case MYSQL:
case POSTGRES:
{
Result<Record> result=create().select(TAuthor_ID()).from(TAuthor()).forShare().fetch();
assertEquals(2,result.size());
Result<A> result2=create().selectFrom(TAuthor()).forShare().fetch();
assertEquals(2,result2.size());
break;
}
default :
log.info("SKIPPING","FOR SHARE clause tests");
}
}

{
  boolean inline=context.inline();
  CastMode castMode=context.castMode();
switch (context.getDialect()) {
case MYSQL:
case H2:
case HSQLDB:
case POSTGRES:
case SQLITE:
{
      context.castMode(NEVER).sql("limit ").sql(numberOfRows).sql(" offset ").sql(offsetOrZero).castMode(castMode);
      break;
    }
case DERBY:
{
    context.castMode(NEVER).sql("offset ").sql(offsetOrZero).sql(" rows fetch next ").sql(numberOfRows).sql(" rows only").castMode(castMode);
    break;
  }
case INGRES:
{
  context.inline(true).sql("offset ").sql(offsetOrZero).sql(" fetch first ").sql(numberOfRows).sql(" rows only").inline(inline);
  break;
}
case SYBASE:
{
context.inline(true).sql("top ").sql(numberOfRows).sql(" start at ").sql(offsetPlusOne).inline(inline);
break;
}
case DB2:
{
if (offset != null) {
throw new DataAccessException("DB2 does not support offsets in FETCH FIRST ROWS ONLY clause");
}
context.inline(true).sql("fetch first ").sql(numberOfRows).sql(" rows only").inline(inline);
break;
}
case ASE:
case SQLSERVER:
{
if (offset != null) {
throw new DataAccessException("Offsets in TOP clause not supported");
}
context.inline(true).sql("top ").sql(numberOfRows).inline(inline);
break;
}
default :
{
context.castMode(NEVER).sql("limit ").sql(numberOfRows).sql(" offset ").sql(offsetOrZero).castMode(castMode);
break;
}
}
}

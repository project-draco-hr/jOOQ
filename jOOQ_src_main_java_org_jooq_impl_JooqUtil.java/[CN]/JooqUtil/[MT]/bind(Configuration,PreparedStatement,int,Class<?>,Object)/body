{
  SQLDialect dialect=configuration.getDialect();
  if (log.isTraceEnabled()) {
    if (value != null && value.getClass().isArray() && value.getClass() != byte[].class) {
      log.trace("Binding variable " + index,Arrays.asList((Object[])value) + " (" + type+ ")");
    }
 else {
      log.trace("Binding variable " + index,value + " (" + type+ ")");
    }
  }
  if (value == null) {
    int sqlType=FieldTypeHelper.getDataType(dialect,type).getSQLType();
    if (ArrayRecord.class.isAssignableFrom(type)) {
      String typeName=newArrayRecord((Class<ArrayRecord<?>>)type,configuration).getName();
      stmt.setNull(index,sqlType,typeName);
    }
 else     if (sqlType != Types.OTHER) {
      stmt.setNull(index,sqlType);
    }
 else     if (configuration.getDialect() == SQLDialect.SQLSERVER) {
      stmt.setNull(index,sqlType);
    }
 else {
      stmt.setObject(index,null);
    }
  }
 else   if (type == Blob.class) {
    stmt.setBlob(index,(Blob)value);
  }
 else   if (type == Boolean.class) {
    stmt.setBoolean(index,(Boolean)value);
  }
 else   if (type == BigDecimal.class) {
    stmt.setBigDecimal(index,(BigDecimal)value);
  }
 else   if (type == BigInteger.class) {
    stmt.setBigDecimal(index,new BigDecimal((BigInteger)value));
  }
 else   if (type == Byte.class) {
    stmt.setByte(index,(Byte)value);
  }
 else   if (type == byte[].class) {
    stmt.setBytes(index,(byte[])value);
  }
 else   if (type == Clob.class) {
    stmt.setClob(index,(Clob)value);
  }
 else   if (type == Date.class) {
    stmt.setDate(index,(Date)value);
  }
 else   if (type == Double.class) {
    stmt.setDouble(index,(Double)value);
  }
 else   if (type == Float.class) {
    stmt.setFloat(index,(Float)value);
  }
 else   if (type == Integer.class) {
    stmt.setInt(index,(Integer)value);
  }
 else   if (type == Long.class) {
    stmt.setLong(index,(Long)value);
  }
 else   if (type == Short.class) {
    stmt.setShort(index,(Short)value);
  }
 else   if (type == String.class) {
    stmt.setString(index,(String)value);
  }
 else   if (type == Time.class) {
    stmt.setTime(index,(Time)value);
  }
 else   if (type == Timestamp.class) {
    stmt.setTimestamp(index,(Timestamp)value);
  }
 else   if (type.isArray()) {
switch (dialect) {
case POSTGRES:
{
        StringBuilder sb=new StringBuilder();
        sb.append("{");
        String separator="";
        for (        Object o : (Object[])value) {
          sb.append(separator);
          if (o == null) {
            sb.append(o);
          }
 else {
            sb.append("\"");
            sb.append(o.toString().replaceAll("\"","\"\""));
            sb.append("\"");
          }
          separator=", ";
        }
        sb.append("}");
        stmt.setString(index,sb.toString());
        break;
      }
case HSQLDB:
    stmt.setArray(index,new DefaultArray(dialect,(Object[])value,type));
  break;
case H2:
stmt.setObject(index,value);
break;
default :
throw new SQLDialectNotSupportedException("Cannot bind ARRAY types in dialect " + dialect);
}
}
 else if (ArrayRecord.class.isAssignableFrom(type)) {
stmt.setArray(index,((ArrayRecord<?>)value).createArray());
}
 else if (EnumType.class.isAssignableFrom(type)) {
stmt.setString(index,((EnumType)value).getLiteral());
}
 else if (MasterDataType.class.isAssignableFrom(type)) {
Object primaryKey=((MasterDataType<?>)value).getPrimaryKey();
bind(configuration,stmt,index,primaryKey.getClass(),primaryKey);
}
 else {
stmt.setObject(index,value);
}
}

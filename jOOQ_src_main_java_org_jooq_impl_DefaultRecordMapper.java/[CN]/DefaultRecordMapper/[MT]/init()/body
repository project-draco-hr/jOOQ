{
  if (type.isArray()) {
    delegate=new ArrayMapper();
    return;
  }
  if (type.isPrimitive() || DefaultDataType.types().contains(type)) {
    delegate=new ValueTypeMapper();
    return;
  }
  if (Modifier.isAbstract(type.getModifiers())) {
    delegate=new ProxyMapper();
    return;
  }
  if (AbstractRecord.class.isAssignableFrom(type)) {
    delegate=(RecordMapper<R,E>)new RecordToRecordMapper();
    return;
  }
  try {
    delegate=new MutablePOJOMapper(type.getDeclaredConstructor());
    return;
  }
 catch (  NoSuchMethodException ignore) {
  }
  Constructor<E>[] constructors=(Constructor<E>[])type.getDeclaredConstructors();
  for (  Constructor<E> constructor : constructors) {
    ConstructorProperties properties=constructor.getAnnotation(ConstructorProperties.class);
    if (properties != null) {
      delegate=new ImmutablePOJOMapperWithConstructorProperties(constructor,properties);
      return;
    }
  }
  for (  Constructor<E> constructor : constructors) {
    Class<?>[] parameterTypes=constructor.getParameterTypes();
    if (parameterTypes.length == fields.length) {
      delegate=new ImmutablePOJOMapper(constructor,parameterTypes);
      return;
    }
  }
  throw new MappingException("No matching constructor found on type " + type + " for record "+ this);
}

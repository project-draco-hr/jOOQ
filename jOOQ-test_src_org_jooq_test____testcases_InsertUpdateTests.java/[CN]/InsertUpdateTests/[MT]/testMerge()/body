{
switch (dialect()) {
case ASE:
case INGRES:
case DERBY:
case H2:
case MARIADB:
case MYSQL:
case POSTGRES:
case SQLITE:
    log.info("SKIPPING","Merge tests");
  return;
}
jOOQAbstractTest.reset=false;
create().mergeInto(TAuthor()).using(selectOne()).on("1 = 1").whenMatchedThenUpdate().set(TAuthor_FIRST_NAME(),"Alfred").whenNotMatchedThenInsert(TAuthor_ID(),TAuthor_LAST_NAME()).values(3,"Hitchcock").execute();
assertEquals(Arrays.asList("Alfred","Alfred"),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
create().mergeInto(TAuthor()).using(selectOne()).on(TAuthor_ID().equal(1)).whenMatchedThenUpdate().set(TAuthor_FIRST_NAME(),"John").whenNotMatchedThenInsert(TAuthor_ID(),TAuthor_LAST_NAME()).values(3,"Hitchcock").execute();
assertEquals(Arrays.asList("John","Alfred"),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
Field<String> f=val("Dan").as("f");
Field<String> l=val("Brown").as("l");
MergeFinalStep<A> q=create().mergeInto(TAuthor()).using(select(f,l)).on(TAuthor_LAST_NAME().equal(l)).whenMatchedThenUpdate().set(TAuthor_FIRST_NAME(),"James").whenNotMatchedThenInsert().set(TAuthor_ID(),3).set(TAuthor_FIRST_NAME(),f).set(TAuthor_LAST_NAME(),l);
q.execute();
assertEquals(Arrays.asList("John","Alfred","Dan"),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
q.execute();
assertEquals(Arrays.asList("John","Alfred","James"),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
f=val("Herman").as("f");
l=val("Hesse").as("l");
q=create().mergeInto(TAuthor()).using(create().select(f,l)).on(TAuthor_LAST_NAME().equal(l)).whenNotMatchedThenInsert(Arrays.<Field<?>>asList(TAuthor_ID(),TAuthor_FIRST_NAME(),TAuthor_LAST_NAME(),TAuthor_DATE_OF_BIRTH())).values("4",f,l,0L);
q.execute();
assertEquals(Arrays.asList("John","Alfred","James","Herman"),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
q.execute();
assertEquals(Arrays.asList("John","Alfred","James","Herman"),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
}

{
  try {
    String[] types=null;
switch (configuration.dialect().family()) {
case POSTGRES:
      types=new String[]{"TABLE","VIEW","SYSTEM_TABLE","SYSTEM_VIEW","MATERIALIZED VIEW"};
    break;
case SQLITE:
  types=new String[]{"TABLE","VIEW"};
break;
}
ResultSet rs;
if (!inverseSchemaCatalog) {
rs=meta().getTables(null,getName(),"%",types);
}
 else {
rs=meta().getTables(getName(),null,"%",types);
}
List<Table<?>> result=new ArrayList<Table<?>>();
Result<Record> tables=create.fetch(rs,SQLDataType.VARCHAR,SQLDataType.VARCHAR,SQLDataType.VARCHAR,SQLDataType.VARCHAR);
for (Record table : tables) {
String catalog=table.getValue(0,String.class);
String schema=table.getValue(1,String.class);
String name=table.getValue(2,String.class);
result.add(new MetaTable(name,this,getColumns(inverseSchemaCatalog ? catalog : schema,name)));
}
return result;
}
 catch (SQLException e) {
throw new DataAccessException("Error while accessing DatabaseMetaData",e);
}
}

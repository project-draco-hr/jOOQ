{
  ResultSet rs=ctx.resultSet();
  if (type == Blob.class) {
    return (T)rs.getBlob(index);
  }
 else   if (type == Boolean.class) {
    return (T)wasNull(rs,Boolean.valueOf(rs.getBoolean(index)));
  }
 else   if (type == BigInteger.class) {
    if (ctx.configuration().dialect() == SQLDialect.SQLITE) {
      return Convert.convert(rs.getString(index),(Class<T>)BigInteger.class);
    }
 else {
      BigDecimal result=rs.getBigDecimal(index);
      return (T)(result == null ? null : result.toBigInteger());
    }
  }
 else   if (type == BigDecimal.class) {
    if (ctx.configuration().dialect() == SQLDialect.SQLITE) {
      return Convert.convert(rs.getString(index),(Class<T>)BigDecimal.class);
    }
 else {
      return (T)rs.getBigDecimal(index);
    }
  }
 else   if (type == Byte.class) {
    return (T)wasNull(rs,Byte.valueOf(rs.getByte(index)));
  }
 else   if (type == byte[].class) {
    return (T)rs.getBytes(index);
  }
 else   if (type == Clob.class) {
    return (T)rs.getClob(index);
  }
 else   if (type == Date.class) {
    return (T)getDate(ctx.configuration().dialect(),rs,index);
  }
 else   if (type == Double.class) {
    return (T)wasNull(rs,Double.valueOf(rs.getDouble(index)));
  }
 else   if (type == Float.class) {
    return (T)wasNull(rs,Float.valueOf(rs.getFloat(index)));
  }
 else   if (type == Integer.class) {
    return (T)wasNull(rs,Integer.valueOf(rs.getInt(index)));
  }
 else   if (type == Long.class) {
    return (T)wasNull(rs,Long.valueOf(rs.getLong(index)));
  }
 else   if (type == Short.class) {
    return (T)wasNull(rs,Short.valueOf(rs.getShort(index)));
  }
 else   if (type == String.class) {
    return (T)rs.getString(index);
  }
 else   if (type == Time.class) {
    return (T)getTime(ctx.configuration().dialect(),rs,index);
  }
 else   if (type == Timestamp.class) {
    return (T)getTimestamp(ctx.configuration().dialect(),rs,index);
  }
 else   if (type == YearToMonth.class) {
    if (ctx.configuration().dialect() == POSTGRES) {
      Object object=rs.getObject(index);
      return (T)(object == null ? null : PostgresUtils.toYearToMonth(object));
    }
 else {
      String string=rs.getString(index);
      return (T)(string == null ? null : YearToMonth.valueOf(string));
    }
  }
 else   if (type == DayToSecond.class) {
    if (ctx.configuration().dialect() == POSTGRES) {
      Object object=rs.getObject(index);
      return (T)(object == null ? null : PostgresUtils.toDayToSecond(object));
    }
 else {
      String string=rs.getString(index);
      return (T)(string == null ? null : DayToSecond.valueOf(string));
    }
  }
 else   if (type == UByte.class) {
    String string=rs.getString(index);
    return (T)(string == null ? null : UByte.valueOf(string));
  }
 else   if (type == UShort.class) {
    String string=rs.getString(index);
    return (T)(string == null ? null : UShort.valueOf(string));
  }
 else   if (type == UInteger.class) {
    String string=rs.getString(index);
    return (T)(string == null ? null : UInteger.valueOf(string));
  }
 else   if (type == ULong.class) {
    String string=rs.getString(index);
    return (T)(string == null ? null : ULong.valueOf(string));
  }
 else   if (type == UUID.class) {
switch (ctx.configuration().dialect().family()) {
case H2:
case POSTGRES:
{
        return (T)rs.getObject(index);
      }
case SQLSERVER:
case SYBASE:
default :
{
      return (T)Convert.convert(rs.getString(index),UUID.class);
    }
}
}
 else if (type.isArray()) {
switch (ctx.configuration().dialect()) {
case POSTGRES:
{
    return pgGetArray(ctx,type,index);
  }
default :
return (T)convertArray(rs.getArray(index),(Class<? extends Object[]>)type);
}
}
 else if (ArrayRecord.class.isAssignableFrom(type)) {
return (T)getArrayRecord(ctx.configuration(),rs.getArray(index),(Class<? extends ArrayRecord<?>>)type);
}
 else if (EnumType.class.isAssignableFrom(type)) {
return getEnumType(type,rs.getString(index));
}
 else if (UDTRecord.class.isAssignableFrom(type)) {
switch (ctx.configuration().dialect()) {
case POSTGRES:
return (T)pgNewUDTRecord(type,rs.getObject(index));
}
return (T)rs.getObject(index,DataTypes.udtRecords());
}
 else if (Result.class.isAssignableFrom(type)) {
ResultSet nested=(ResultSet)rs.getObject(index);
return (T)DSL.using(ctx.configuration()).fetch(nested);
}
 else {
return (T)unlob(rs.getObject(index));
}
}
